first, lets take a look on the code we build upon the stack. it is built as follows:
1. "pop ebp" gadget address, and after that the address of the puts function. this will cause this address to be stored in ebp. 
2. address of puts fucntion, following the address of gadget2 (we'll get that in a sec), a pointer to the string we want to print. this will make a call to the puts fucntion with the string as argument, and after that we will return to the address of gadget2, so it will be executed.
** gadget2- add esp,4. this will be called after the reutrn from the puts fucntion. we are needing that so we could just skip the pointer to the string, and not trying to return to there. meaning that it will cause esp just point directly to 3. This is necessary inorder to make sure that the next gadget that is going to be executed is gadget(3) - the loop back. otherwise, esp would point to our string, and tring to execute it as commands. 
3. pop esp gadget address, following the address of the memory address we worte (2). this will cause that esp will point back to the call to that address, and we will start execute our code again. this will result an endless loop of our code. 
so, our password is going to look like that:
 *135 bytes of 'a'- this is only for padding* + *"pop ebp" gadget address* + *address of puts* + *address of puts, again- lets call this location- @* + * "add esp, 4" gadget address- this is here to be the return address from puts* + *pointer to the requested string to be printed- this is here as an argument for puts* +"pop esp" gadget address* + *address of the (@)* + our string we want to print. this we will get by calling the get_string function with my ID. 
 So, how the puts fucntion does not running over it own return address? if we look at the disassembly of the puts function we will find out that the first thing that the puts function does, is to push ebp. this will indeed caude an override of the code we worte, but only gonna override the address of puts, with the address of puts (because this what we put in ebp). After that, esp is under our relevant part of our rop, so this is not matter if the fucntion gonna override some other things. lastly, the puts function pop the value she pushed back to ebp. this will cause that esp is going to be right back ar the right place, and ebp will contain the address of puts again. this will keep things just as before we called the puts fucntion. 
in order to include my string in the ROP, I simply called the get_string function with my ID, and add that to the end of the rop. this cause the string to be in the memory, right afer the rop itself, on the stack as well. from a simple calculation I got the address of that location. 
 
